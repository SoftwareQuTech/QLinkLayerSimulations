import abc
from functools import partial
from collections import OrderedDict
from easysquid.toolbox import create_logger, SimulationScheduler
from netsquid.pydynaa import Entity, EventType
from netsquid.simutil import sim_time
from netsquid import get_qstate_formalism, DM_FORMALISM, KET_FORMALISM, STAB_FORMALISM

logger = create_logger("logger")


class SimulationScenario(Entity, metaclass=abc.ABCMeta):
    """
    Simple scenario class that allow scheduling functions at specified timestemps in pydynaa discrete simulator
    """
    def __init__(self):
        self.sim_scheduler = SimulationScheduler()

    def _schedule_action(self, func, sim_time):
        self.sim_scheduler.schedule_function(func=func, t=sim_time)


class EGPSimulationScenario(SimulationScenario):
    def __init__(self, egp):
        """
        EGP simulation scenario that schedules create calls onto the EGP and acts as a higher layer protocol that can
        collect the ok messages and errors returned by the EGP operation
        :param egp: obj `~qlinklayer.egp.EGP`
            The EGP we want to call to for entanglement generation
        """
        super(EGPSimulationScenario, self).__init__()
        # Our EGP
        self.egp = egp

        # Hook up a handler to the ok events
        self.egp.ok_callback = self.ok_callback
        self._EVT_OK = EventType("EGP OK", "Triggers when egp has issued an ok message")

        # Hook up a handler to the error events
        self.egp.err_callback = self.err_callback
        self._EVT_ERR = EventType("EGP ERR", "Triggers when egp has issued an err message")

        # Hook up a handler to the create events
        self.create_storage = []
        self._EVT_CREATE = EventType("EGP CREATE", "Triggers when create was called")

    def schedule_create(self, request, t):
        """
        Given a request and timestep will schedule a call to the egp's "create" method
        :param request: obj `~qlinklayer.egp.EGPRequest`
            The request to pass to egp's create
        :param t: float
            Timestamp in simulation to call the create
        """
        func_create = partial(self._create, request=request)
        self._schedule_action(func_create, sim_time=t)

    def _create(self, request):
        """
        Internal method for calling the EGP's create method and storing the creation id and timestamp info for
        data collection
        :param request: obj `~qlinklayer.egp.EGPRequest`
            The request we are creating
        """
        # Only extract result information if the create was successfully submitted
        result = self.egp.create(creq=request)
        if result is not None:
            self.create_storage.append((self.egp.node.nodeID, request))
            logger.debug("Scheduling create event now.")
            self._schedule_now(self._EVT_CREATE)

    def get_create_info(self, remove=True):
        """
        For use by data collectors to track the creation information
        :param remove: bool
            Whether to remove this data from the storage
        :return: tuple of (int, float)
            Creation ID and simulation timestamp of create call
        """
        create_info = self.create_storage.pop(0) if remove else self.create_storage[0]
        return create_info

    def ok_callback(self, result):
        """
        Handler for oks issued by the EGP containing generation result information.  Schedules an event for data
        collection
        :param result: tuple
            The result of our create request
        """
        self._ok_callback(result)
        logger.debug("Scheduling OK event now.")
        self._schedule_now(self._EVT_OK)

    @abc.abstractmethod
    def _ok_callback(self, result):
        """
        Internal handler for ok messages
        :param result: tuple
            Result from the EGP
        """
        pass

    def err_callback(self, result):
        """
        Handler for errors thrown by the EGP during the simulation.  Schedules an event for data collection
        :param result: tuple
            Result information containing the error
        """
        self._err_callback(result)
        logger.debug("Scheduling error event now.")
        self._schedule_now(self._EVT_ERR)

    @abc.abstractmethod
    def _err_callback(self, result):
        """
        Internal handler for errors thrown by the EGP
        :param result: tuple
            Error information returned by EGP
        """
        pass


class MeasureAfterSuccessScenario(EGPSimulationScenario):
    def __init__(self, egp):
        """
        A simulation scenario that will immediately measure any entangled qubits generated by the EGP
        :param egp: obj `~qlinklayer.egp.EGP`
            The egp we will make create requests to and collect entanglement from
        """
        super(MeasureAfterSuccessScenario, self).__init__(egp=egp)

        # EGP internal objects
        self.node = egp.node
        self.qmm = egp.qmm

        # Data storage from collected info
        self.ok_storage = []
        self.entangled_qstates = []
        self.measurement_results = []
        self.err_storage = []

    def _ok_callback(self, result):
        """
        Internal handler for collecting oks issued by the EGP.  Will extract the result information from the EGP,
        measure the qubit in the memory and release it making it available to the EGP again.
        :param result: tuple
            OK information returned by the EGP
        """
        # Store data for retrieval
        self.ok_storage.append(result)

        # Extract fields from result
        create_id, ent_id, f_goodness, t_create, t_goodness = result
        creator_id, peer_id, mhp_seq, logical_id = ent_id

        # Store the qubit state for collection
        self.store_qstate(logical_id)

        # Measure the logical qubit in the result
        [outcome] = self.node.qmem.measure_subset([logical_id])

        now = sim_time()
        logger.info("{} measured {} for ent_id {} at time {}".format(self.node.nodeID, outcome, ent_id, now))

        # Store the measurement result for data collection
        self.measurement_results.append((mhp_seq, outcome))

        # Free the qubit for the EGP
        self.qmm.free_qubit(logical_id)

    def store_qstate(self, qubit_id):
        """
        Extracts the qubit state based on the used formalism and stores it locally for collection
        :param qubit_id: int
            The qubit ID in memory that we want the state of
        """
        qstate = self.node.qmem.peek(qubit_id).qstate
        formalism = get_qstate_formalism()

        if formalism == DM_FORMALISM and qstate.dm.shape == (4, 4):
            self.entangled_qstates.append(qstate.dm)

        elif formalism == KET_FORMALISM and qstate.ket.shape == (4, 1):
            self.entangled_qstates.append(qstate.ket)

        elif formalism == STAB_FORMALISM:
            self.entangled_qstates.append(qstate.stab)

        else:
            self.entangled_qstates.append(None)

    def get_qstate(self, remove=True):
        """
        Returns the entangled state of the oldest generated pair
        :param remove: bool
            Whether to remove the state info from the scenario's storage
        :return: obj `~numpy.matrix`
            The matrix representation of the qubit state
        """
        state = self.entangled_qstates.pop(0) if remove else self.entangled_qstates[0]
        return state

    def get_ok(self, remove=True):
        """
        Returns the oldest ok message that we received during the simulation
        :param remove: bool
            Whether to remove the ok from the scenario's storage
        :return: tuple
            Ok information
        """
        ok = self.ok_storage.pop(0) if remove else self.ok_storage[0]
        return ok

    def get_measurement(self, remove=True):
        """
        Returns the oldest measurement result that we received during the simulation
        :param remove: bool
            Whether to remove the measurement result from the scenario's storage
        """
        measurement = self.measurement_results.pop(0) if remove else self.measurement_results[0]
        return measurement

    def _err_callback(self, result):
        """
        Collects the errors from the EGP and stores them for data collection
        :param result: tuple
            Contains the error information from the EGP
        """
        now = sim_time()
        logger.error("{} got error {} at time {}".format(self.node.nodeID, result, now))
        self.err_storage.append(result)

    def get_error(self, remove=True):
        """
        Returns the oldest error that we received during the simulation
        :param remove: bool
            Whether to remove the error data from the scenario's storage
        """
        err = self.err_storage.pop(0) if remove else self.err_storage[0]
        return err


class MeasureBeforeSuccessScenario(EGPSimulationScenario):
    """
    Scenario for when spin is measured directly after photon is emitted, i.e. before messages is returned
    from midpoint. The classical information from the choice of measurement basis and measurement
    outcome can be used to compute QubErr and/or produce key.
    """
    def __init__(self, egp):
        super(MeasureBeforeSuccessScenario, self).__init__(egp=egp)

        # EGP internal objects
        self.node = egp.node
        self.qmm = egp.qmm

        # Data storage from collected info
        self.ok_storage = []
        self.measurement_storage = OrderedDict()
        self.err_storage = []

    def _ok_callback(self, result):
        """
        Internal handler for collecting oks issued by the EGP. Will extract the result information from EGP.
        :param result: tuple
            OK information returned by the EGP
        :return: None
        """
        # Store data for retrieval
        self.ok_storage.append(result)

        # Extract fields from result
        create_id, ent_id, f_goodness, t_create, t_goodness = result
        creator_id, peer_id, mhp_seq, logical_id = ent_id

        # Store the basis/bit choice and the midpoint outcomes for QubErr or key generation
        meas_data = (self.egp.basis_choice, self.egp.bit_choice, self.egp.midpoint_outcome)
        self.measurement_storage[ent_id] = meas_data

        # Free the qubit for the EGP
        self.qmm.free_qubit(logical_id)

    def get_ok(self, remove=True):
        """
        Returns the oldest ok message that we received during the simulation
        :param remove: bool
            Whether to remove the ok from the scenario's storage
        :return: tuple
            Ok information
        """
        ok = self.ok_storage.pop(0) if remove else self.ok_storage[0]
        return ok

    def get_measurement(self, ent_id=None, remove=True):
        """
        Returns the measurement result corresponding to the given entanglement id.
        If ent_id is None, the first item (ent_id, meas_data) is returned and deleted, independently of 'remove'.
        :param remove: bool
            Whether to remove the measurement result from the scenario's storage
        :param ent_id: tuple or None
            The entanglement ID
        :return: tuple
            Returns the entanglement ID and the measurement data as (ent_id, meas_data)
        """
        if ent_id is None:
            try:
                # Get the key of the first item
                ent_id = next(iter(self.measurement_storage))
                meas_data = self.measurement_storage.pop(ent_id) if remove else self.measurement_storage[ent_id]
                return ent_id, meas_data
            except StopIteration:
                return None, None
        else:
            try:
                meas_data = self.measurement_storage.pop(ent_id) if remove else self.measurement_storage[ent_id]
                return ent_id, meas_data
            except KeyError:
                return None, None

    def _err_callback(self, result):
        """
        Collects the errors from the EGP and stores them for data collection
        :param result: tuple
            Contains the error information from the EGP
        """
        now = sim_time()
        logger.error("{} got error {} at time {}".format(self.node.nodeID, result, now))
        self.err_storage.append(result)

    def get_error(self, remove=True):
        """
        Returns the oldest error that we received during the simulation
        :param remove: bool
            Whether to remove the error data from the scenario's storage
        """
        err = self.err_storage.pop(0) if remove else self.err_storage[0]
        return err
